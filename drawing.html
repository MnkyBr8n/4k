<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing App - 4K Digital Art</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* Drawing App Specific Styles */
        .drawing-section {
            min-height: 100vh;
            padding: 120px 0 50px;
        }

        .drawing-header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .drawing-header h1 {
            font-size: 3rem;
            color: white;
            margin-bottom: 1rem;
        }

        .drawing-header p {
            font-size: 1.2rem;
            color: rgba(255,255,255,0.9);
            max-width: 600px;
            margin: 0 auto;
        }

        .drawing-app {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 2rem;
            backdrop-filter: blur(10px);
        }

        .drawing-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            color: white;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .control-group input,
        .control-group select {
            padding: 10px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            background: rgba(255,255,255,0.9);
        }

        .control-group input[type="color"] {
            width: 60px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            padding: 0;
        }

        .control-group input[type="range"] {
            background: rgba(255,255,255,0.9);
        }

        .size-display {
            color: white;
            font-weight: bold;
            text-align: center;
            margin-top: 5px;
        }

        .canvas-container {
            position: relative;
            text-align: center;
            margin-bottom: 2rem;
        }

        #drawingCanvas {
            border: 4px solid rgba(255,255,255,0.4);
            border-radius: 15px;
            background: white;
            cursor: crosshair;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 100%;
            height: auto;
        }

        .canvas-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .canvas-actions .btn {
            padding: 12px 24px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
        }

        .canvas-actions .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .canvas-actions .btn.secondary {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
        }

        .canvas-actions .btn.secondary:hover {
            background: rgba(255,255,255,0.3);
        }

        .drawing-tips {
            margin-top: 3rem;
            background: rgba(255,255,255,0.1);
            padding: 2rem;
            border-radius: 15px;
        }

        .drawing-tips h3 {
            color: white;
            margin-bottom: 1rem;
            text-align: center;
        }

        .tips-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }

        .tip-item {
            background: rgba(255,255,255,0.1);
            padding: 1rem;
            border-radius: 10px;
            color: white;
        }

        .tip-item strong {
            color: #fff;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .drawing-controls {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .control-group {
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
            }

            .control-group input,
            .control-group select {
                flex: 1;
                max-width: 150px;
            }

            #drawingCanvas {
                width: 100%;
                max-width: 100%;
            }

            .canvas-actions {
                flex-direction: column;
                align-items: center;
            }

            .canvas-actions .btn {
                width: 200px;
            }
        }

        /* Touch device optimizations */
        @media (pointer: coarse) {
            #drawingCanvas {
                cursor: none;
            }

            .control-group input[type="range"] {
                height: 40px;
            }

            .canvas-actions .btn {
                padding: 15px 30px;
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <div class="logo">4K</div>
            <ul class="nav-links">
                <li><a href="index.html">Home</a></li>
                <li><a href="gallery.html">Gallery</a></li>
                <li><a href="about.html">About Me</a></li>
                <li><a href="commissions.html">Commissions</a></li>
                <li><a href="drawing.html" class="active">Draw</a></li>
            </ul>
            <div class="mobile-menu-btn">☰</div>
        </div>
    </nav>

    <!-- Drawing Section -->
    <section class="drawing-section">
        <div class="container">
            <div class="drawing-header">
                <h1>Interactive Drawing Canvas</h1>
                <p>Express your creativity with my digital drawing tool! Choose your colors, adjust brush sizes, and create amazing artwork right in your browser.</p>
            </div>

            <div class="drawing-app">
                <div class="drawing-controls">
                	<div class="control-group">
  <label for="hexInput">Hex (AA supported)</label>
  <input id="hexInput" type="text" value="#000000ff" placeholder="#RRGGBBAA">
</div>

<div class="control-group">
  <label>&nbsp;</label>
  <button class="btn secondary" id="eyedropperBtn" title="Alt/Option+Click also works">Eyedropper</button>
</div>
                    <div class="control-group">
                        <label for="brushColor">Brush Color</label>
                        <input type="color" id="brushColor" value="#000000">
                    </div>

                    <div class="control-group">
                        <label for="brushSize">Brush Size</label>
                        <input type="range" id="brushSize" min="1" max="100" value="5">
                        <div class="size-display" id="sizeDisplay">5px</div>
                    </div>

                    <div class="control-group">
                        <label for="brushType">Tool</label>
                        <select id="brushType">
                            <option value="brush">Brush</option>
                            <option value="eraser">Eraser</option>
                            <option value="spray">Spray Paint</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label for="opacity">Opacity</label>
                        <input type="range" id="opacity" min="10" max="100" value="100">
                        <div class="size-display" id="opacityDisplay">100%</div>
                    </div>
                </div>
				
				<div class="layers-panel" style="margin-bottom:1rem;background:rgba(255,255,255,0.1);padding:14px;border-radius:12px;">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
    <strong style="color:white;">Layers</strong>
    <div>
      <button class="btn secondary" onclick="layerUI.addLayer()">+ Layer</button>
      <button class="btn secondary" onclick="layerUI.duplicateLayer()">Duplicate</button>
      <button class="btn secondary" onclick="layerUI.deleteLayer()">Delete</button>
    </div>
  </div>
  <div id="layersList" style="display:flex;flex-direction:column;gap:8px;"></div>
</div>
             
			   <div class="canvas-container">
                    <canvas id="drawingCanvas" width="1000" height="800"></canvas>
                </div>

                <div class="canvas-actions">
                    <button class="btn" onclick="clearCanvas()">Clear Canvas</button>
                    <button class="btn" onclick="undoLastStroke()">Undo</button>
                    <button class="btn secondary" onclick="saveDrawing()">Save Drawing</button>
                    <button class="btn secondary" onclick="loadImage()">Load Image</button>
                    <input type="file" id="imageLoader" accept="image/*" style="display: none;">
                </div>
            </div>

            <div class="drawing-tips">
                <h3>Drawing Tips & Tricks</h3>
                <div class="tips-grid">
                    <div class="tip-item">
                        <strong>Brush Control:</strong> Use smaller brush sizes for details and larger sizes for filling areas. The spray paint tool creates a textured effect!
                    </div>
                    <div class="tip-item">
                        <strong>Layer Planning:</strong> Start with light sketches, then add darker lines and colors. Use the opacity slider for subtle effects.
                    </div>
                    <div class="tip-item">
                        <strong>Color Harmony:</strong> Try using colors that are next to each other on the color wheel for pleasing combinations.
                    </div>
                    <div class="tip-item">
                        <strong>Mobile Drawing:</strong> On touch devices, use your finger for broad strokes and a stylus for fine details.
                    </div>
                </div>
            </div>
        </div>
    </section>

    <script src="main.js"></script>
    <script>
class Layer {
  constructor(width, height, name = "Layer") {
    this.id = crypto.randomUUID();
    this.name = name;
    this.visible = true;
    this.opacity = 1.0;
    this.canvas = document.createElement('canvas');
    this.canvas.width = width;
    this.canvas.height = height;
    this.ctx = this.canvas.getContext('2d');
    this.undoStack = []; // ImageData snapshots for undo
  }

  snapshot(max = 30) {
    try {
      const data = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      this.undoStack.push(data);
      if (this.undoStack.length > max) this.undoStack.shift();
    } catch (e) {
      // cross-origin images can block getImageData; ignore in that rare case
    }
  }

  undo() {
    if (!this.undoStack.length) return;
    const img = this.undoStack.pop();
    this.ctx.putImageData(img, 0, 0);
  }
}

class DrawingApp {
  constructor() {
    this.canvas = document.getElementById('drawingCanvas');        // display canvas
    this.ctx = this.canvas.getContext('2d');                        // display context
    this.isDrawing = false;
    this.lastX = 0;
    this.lastY = 0;
    this.layers = [];
    this.activeLayerIndex = 0;
    this.tool = 'brush';
    this.strokes = []; // kept for compatibility; we now use per-layer snapshots
    this.pointerPressure = 1;

    // DOM
    this.brushTypeEl = document.getElementById('brushType');
    this.brushColorEl = document.getElementById('brushColor');
    this.brushSizeEl = document.getElementById('brushSize');
    this.opacityEl = document.getElementById('opacity');
    this.sizeDisplayEl = document.getElementById('sizeDisplay');
    this.opacityDisplayEl = document.getElementById('opacityDisplay');
    this.hexInputEl = document.getElementById('hexInput');
    this.eyedropperBtn = document.getElementById('eyedropperBtn');

    this.init();
  }

  init() {
    // white background for display canvas, but we’ll render layers on top
    this.ctx.fillStyle = 'white';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    // default stroke caps
    this.ctx.lineJoin = 'round';
    this.ctx.lineCap = 'round';

    // Create first layer
    this.addLayer("Layer 1", true);

    this.setupEventListeners();
    this.updateDisplays();
    this.renderAll(); // initial render
  }

  // ===== Layers =====
  addLayer(name = null, setActive = false) {
    const layer = new Layer(this.canvas.width, this.canvas.height, name ?? `Layer ${this.layers.length + 1}`);
    // initialize as transparent
    layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
    this.layers.push(layer);
    if (setActive) this.activeLayerIndex = this.layers.length - 1;
    layer.snapshot(); // initial state for undo baseline
    LayerUI.refresh();
    this.renderAll();
  }

  deleteLayer(index = this.activeLayerIndex) {
    if (this.layers.length <= 1) return; // keep at least one
    this.layers.splice(index, 1);
    if (this.activeLayerIndex >= this.layers.length) {
      this.activeLayerIndex = this.layers.length - 1;
    }
    LayerUI.refresh();
    this.renderAll();
  }

  duplicateLayer(index = this.activeLayerIndex) {
    const src = this.layers[index];
    const copy = new Layer(this.canvas.width, this.canvas.height, src.name + " copy");
    copy.ctx.globalAlpha = 1;
    copy.ctx.drawImage(src.canvas, 0, 0);
    copy.snapshot();
    this.layers.splice(index + 1, 0, copy);
    this.activeLayerIndex = index + 1;
    LayerUI.refresh();
    this.renderAll();
  }

  moveLayer(index, direction) {
    const newIndex = index + direction; // -1 up, +1 down
    if (newIndex < 0 || newIndex >= this.layers.length) return;
    const [l] = this.layers.splice(index, 1);
    this.layers.splice(newIndex, 0, l);
    this.activeLayerIndex = newIndex;
    LayerUI.refresh();
    this.renderAll();
  }

  setActiveLayer(i) {
    this.activeLayerIndex = i;
    LayerUI.refresh();
  }

  toggleVisibility(i) {
    this.layers[i].visible = !this.layers[i].visible;
    LayerUI.refresh();
    this.renderAll();
  }

  // Flatten and draw to display canvas
  renderAll() {
    // clear display
    this.ctx.save();
    this.ctx.globalAlpha = 1;
    this.ctx.globalCompositeOperation = 'source-over';
    this.ctx.fillStyle = 'white';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    // draw each visible layer in order
    for (const layer of this.layers) {
      if (!layer.visible) continue;
      this.ctx.globalAlpha = layer.opacity;
      this.ctx.drawImage(layer.canvas, 0, 0);
    }
    this.ctx.restore();
  }

  // ===== Events & Tools =====
  setupEventListeners() {
    // Pointer (handles mouse+pen+touch)
    const start = (e) => { this.startDrawing(e); };
    const move  = (e) => { this.draw(e); };
    const end   = () =>   { this.stopDrawing(); };

    this.canvas.addEventListener('pointerdown', start);
    this.canvas.addEventListener('pointermove', move);
    window.addEventListener('pointerup', end);
    this.canvas.addEventListener('pointerleave', end);

    // Controls
    this.brushSizeEl.addEventListener('input', () => this.updateDisplays());
    this.opacityEl.addEventListener('input', () => this.updateDisplays());
    this.brushTypeEl.addEventListener('change', () => { this.tool = this.brushTypeEl.value; });

    // Hex input: accept #RRGGBB or #RRGGBBAA
    this.hexInputEl.addEventListener('change', () => {
      const val = this.normalizeHex(this.hexInputEl.value);
      if (val) {
        this.hexInputEl.value = val;
        // set <input type="color"> to opaque portion
        this.brushColorEl.value = '#' + val.slice(1, 7);
      }
    });

    // sync color input back to hex (keep alpha if present)
    this.brushColorEl.addEventListener('input', () => {
      const current = this.hexInputEl.value;
      const alpha = current && current.length === 9 ? current.slice(7) : 'ff';
      this.hexInputEl.value = this.normalizeHex(this.brushColorEl.value + alpha);
    });

    // Eyedropper button
    this.eyedropperBtn.addEventListener('click', () => {
      this.awaitEyedropperClick = true;
      this.eyedropperBtn.textContent = 'Click canvas…';
      setTimeout(() => (this.eyedropperBtn.textContent = 'Eyedropper'), 3000);
    });

    // Alt/Option click eyedropper (handled in startDrawing)
  }

  getPos(e) {
    const rect = this.canvas.getBoundingClientRect();
    const scaleX = this.canvas.width / rect.width;
    const scaleY = this.canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    return { x, y };
  }

  startDrawing(e) {
    // Eyedropper?
    if (e.altKey || this.awaitEyedropperClick) {
      this.awaitEyedropperClick = false;
      const { x, y } = this.getPos(e);
      const pixel = this.ctx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data; // from flattened
      const hex = this.rgbaToHex(pixel[0], pixel[1], pixel[2], pixel[3]);
      this.hexInputEl.value = hex;
      this.brushColorEl.value = '#' + hex.slice(1, 7);
      return;
    }

    this.isDrawing = true;
    const { x, y } = this.getPos(e);
    this.lastX = x;
    this.lastY = y;

    // pressure if available
    this.pointerPressure = (e.pressure && e.pressure > 0) ? e.pressure : 1;

    // snapshot for undo on active layer
    const layer = this.layers[this.activeLayerIndex];
    layer.snapshot();
  }

  draw(e) {
    if (!this.isDrawing) return;
    const layer = this.layers[this.activeLayerIndex];
    const lctx = layer.ctx;

    const { x, y } = this.getPos(e);
    this.pointerPressure = (e.pressure && e.pressure > 0) ? e.pressure : this.pointerPressure;

    const brushType = this.brushTypeEl.value;
    const sizeBase = parseFloat(this.brushSizeEl.value);
    const size = Math.max(0.5, sizeBase * this.pointerPressure);
    const hex = this.normalizeHex(this.hexInputEl.value) || '#000000ff';
    const { r, g, b, a } = this.hexToRgba(hex);
    const opacity = parseInt(this.opacityEl.value, 10) / 100;

    lctx.save();
    if (brushType === 'eraser') {
      lctx.globalCompositeOperation = 'destination-out';
      lctx.globalAlpha = opacity;
      lctx.lineWidth = size;
      lctx.lineJoin = 'round';
      lctx.lineCap = 'round';
      lctx.beginPath();
      lctx.moveTo(this.lastX, this.lastY);
      lctx.lineTo(x, y);
      lctx.stroke();
    } else if (brushType === 'spray') {
      lctx.globalCompositeOperation = 'source-over';
      lctx.globalAlpha = opacity * (a / 255);
      lctx.fillStyle = `rgba(${r},${g},${b},${lctx.globalAlpha})`;
      const density = 20;
      for (let i = 0; i < density; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * (size / 2);
        const px = x + Math.cos(angle) * radius;
        const py = y + Math.sin(angle) * radius;
        lctx.beginPath();
        lctx.arc(px, py, Math.max(0.5, size * 0.05), 0, Math.PI * 2);
        lctx.fill();
      }
    } else { // brush
      lctx.globalCompositeOperation = 'source-over';
      lctx.strokeStyle = `rgba(${r},${g},${b},${(a/255) * opacity})`;
      lctx.lineWidth = size;
      lctx.lineJoin = 'round';
      lctx.lineCap = 'round';
      lctx.beginPath();
      lctx.moveTo(this.lastX, this.lastY);
      lctx.lineTo(x, y);
      lctx.stroke();
    }
    lctx.restore();

    this.lastX = x;
    this.lastY = y;

    // re-flatten for display
    this.renderAll();
  }

  stopDrawing() {
    if (!this.isDrawing) return;
    this.isDrawing = false;
  }

  // ===== Utilities =====
  updateDisplays() {
    const brushSize = this.brushSizeEl.value;
    const opacity = this.opacityEl.value;
    this.sizeDisplayEl.textContent = brushSize + 'px';
    this.opacityDisplayEl.textContent = opacity + '%';
  }

  clearCanvas() {
    for (const layer of this.layers) {
      layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
    }
    this.renderAll();
    for (const l of this.layers) l.undoStack = [];
  }

  undoLastStroke() {
    const layer = this.layers[this.activeLayerIndex];
    layer.undo();
    this.renderAll();
  }

  // Flatten to PNG
  saveDrawing() {
    const link = document.createElement('a');
    link.download = '4k-artwork-' + new Date().getTime() + '.png';
    this.renderAll();
    link.href = this.canvas.toDataURL();
    link.click();
  }

  // Save project with layers
  saveProject() {
    const project = {
      version: 1,
      width: this.canvas.width,
      height: this.canvas.height,
      layers: this.layers.map(l => ({
        id: l.id,
        name: l.name,
        visible: l.visible,
        opacity: l.opacity,
        dataURL: l.canvas.toDataURL('image/png')
      })),
      activeLayerIndex: this.activeLayerIndex
    };
    const blob = new Blob([JSON.stringify(project)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `project-${Date.now()}.4kdraw`;
    a.click();
    URL.revokeObjectURL(url);
  }

  async loadProjectFile(file) {
    const text = await file.text();
    const project = JSON.parse(text);
    // resize display canvas if needed
    if (project.width && project.height) {
      this.canvas.width = project.width;
      this.canvas.height = project.height;
    }
    // rebuild layers
    this.layers = [];
    for (const pl of project.layers) {
      const l = new Layer(this.canvas.width, this.canvas.height, pl.name);
      l.visible = pl.visible;
      l.opacity = pl.opacity;
      await this.drawDataUrlToLayer(l.ctx, pl.dataURL);
      l.snapshot();
      this.layers.push(l);
    }
    this.activeLayerIndex = Math.min(project.activeLayerIndex ?? 0, this.layers.length - 1);
    LayerUI.refresh();
    this.renderAll();
  }

  drawDataUrlToLayer(ctx, dataURL) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => { ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height); ctx.drawImage(img, 0, 0); resolve(); };
      img.src = dataURL;
    });
  }

  handleImageLoad(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      const img = new Image();
      img.onload = () => {
        const layer = this.layers[this.activeLayerIndex];
        layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);

        // fit image
        const scale = Math.min(
          this.canvas.width / img.width,
          this.canvas.height / img.height
        );
        const w = img.width * scale;
        const h = img.height * scale;
        const x = (this.canvas.width - w) / 2;
        const y = (this.canvas.height - h) / 2;
        layer.ctx.drawImage(img, x, y, w, h);
        this.renderAll();
      };
      img.src = event.target.result;
    };
    reader.readAsDataURL(file);
  }

  // color helpers
  normalizeHex(v) {
    if (!v) return null;
    let s = v.trim().toLowerCase();
    if (!s.startsWith('#')) s = '#' + s;
    if (s.length === 4) {
      // #rgb -> #rrggbbff
      const r = s[1], g = s[2], b = s[3];
      s = `#${r}${r}${g}${g}${b}${b}ff`;
    } else if (s.length === 7) {
      // #rrggbb -> #rrggbbff
      s = s + 'ff';
    } else if (s.length === 9) {
      // #rrggbbaa OK
    } else {
      return null;
    }
    // validate hex
    if (!/^#[0-9a-f]{8}$/.test(s)) return null;
    return s;
  }

  hexToRgba(hex) {
    const h = this.normalizeHex(hex) ?? '#000000ff';
    const r = parseInt(h.slice(1,3),16);
    const g = parseInt(h.slice(3,5),16);
    const b = parseInt(h.slice(5,7),16);
    const a = parseInt(h.slice(7,9),16);
    return { r,g,b,a };
  }

  rgbaToHex(r,g,b,a=255) {
    const to2 = (n)=> n.toString(16).padStart(2,'0');
    return '#' + to2(r) + to2(g) + to2(b) + to2(a);
  }
}

// ===== Layer UI binder (keeps your styling) =====
const LayerUI = {
  get app() { return drawingApp; },
  el() { return document.getElementById('layersList'); },

  refresh() {
    const root = this.el();
    root.innerHTML = '';
    drawingApp.layers.forEach((layer, i) => {
      const row = document.createElement('div');
      row.style.display = 'grid';
      row.style.gridTemplateColumns = '28px 1fr auto';
      row.style.alignItems = 'center';
      row.style.gap = '8px';
      row.style.background = 'rgba(255,255,255,0.08)';
      row.style.padding = '8px 10px';
      row.style.borderRadius = '8px';

      const vis = document.createElement('input');
      vis.type = 'checkbox';
      vis.checked = layer.visible;
      vis.title = 'Toggle visibility';
      vis.addEventListener('change', () => drawingApp.toggleVisibility(i));

      const name = document.createElement('input');
      name.type = 'text';
      name.value = layer.name;
      name.style.width = '100%';
      name.addEventListener('change', () => { layer.name = name.value; });

      const btns = document.createElement('div');
      btns.style.display = 'flex';
      btns.style.gap = '6px';
      btns.innerHTML = `
        <button class="btn secondary" title="Move up">↑</button>
        <button class="btn secondary" title="Move down">↓</button>
        <button class="btn ${i===drawingApp.activeLayerIndex ? '' : 'secondary'}" title="Activate">Use</button>
      `;
      const [up, down, use] = btns.querySelectorAll('button');
      up.onclick = () => drawingApp.moveLayer(i, -1);
      down.onclick = () => drawingApp.moveLayer(i, +1);
      use.onclick = () => drawingApp.setActiveLayer(i);

      if (i === drawingApp.activeLayerIndex) {
        row.style.outline = '2px solid rgba(255,255,255,0.35)';
      }

      row.appendChild(vis);
      row.appendChild(name);
      row.appendChild(btns);
      root.appendChild(row);
    });
  },

  addLayer() { drawingApp.addLayer(); },
  deleteLayer() { drawingApp.deleteLayer(); },
  duplicateLayer() { drawingApp.duplicateLayer(); },
};

// ===== Global button hooks (keep your existing buttons) =====
let drawingApp;

function clearCanvas() { drawingApp.clearCanvas(); }
function undoLastStroke() { drawingApp.undoLastStroke(); }
function saveDrawing() { drawingApp.saveDrawing(); }

function loadImage() {
  const input = document.getElementById('imageLoader');
  input.onchange = (e) => drawingApp.handleImageLoad(e);
  input.click();
}

// Add project save/load buttons next to your existing actions (optional)
function saveProject() { drawingApp.saveProject(); }
function loadProject() {
  const file = document.createElement('input');
  file.type = 'file';
  file.accept = '.4kdraw,application/json';
  file.onchange = async (e) => {
    if (e.target.files && e.target.files[0]) {
      await drawingApp.loadProjectFile(e.target.files[0]);
    }
  };
  file.click();
}

document.addEventListener('DOMContentLoaded', function() {
  drawingApp = new DrawingApp();

  // Add two new buttons to your .canvas-actions quickly:
  const actions = document.querySelector('.canvas-actions');
  const saveP = document.createElement('button');
  saveP.className = 'btn secondary';
  saveP.textContent = 'Save Project (.4kdraw)';
  saveP.onclick = saveProject;
  const loadP = document.createElement('button');
  loadP.className = 'btn secondary';
  loadP.textContent = 'Load Project';
  loadP.onclick = loadProject;
  actions.appendChild(saveP);
  actions.appendChild(loadP);
});
	</script>
</body>
</html>