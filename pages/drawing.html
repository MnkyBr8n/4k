<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Enhanced Drawing App - 4K Digital Art</title>
  <link rel="stylesheet" href="styles/style.css"/>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --glass: rgba(255,255,255,0.1);
      --glass-strong: rgba(255,255,255,0.2);
      --glass-border: rgba(255,255,255,0.3);
    }
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh; color: white;
    }

    /* Navigation */
    nav {
      position: fixed; top: 0; width: 100%;
      background: rgba(0,0,0,0.9);
      backdrop-filter: blur(10px);
      z-index: 1000; padding: 1rem 0;
    }
    .nav-container {
      max-width: 1200px; margin: 0 auto;
      display: flex; justify-content: space-between; align-items: center;
      padding: 0 2rem;
    }
    .logo {
      font-size: 2rem; font-weight: bold;
      background: linear-gradient(45deg, #667eea, #764ba2);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .nav-links { display: flex; list-style: none; gap: 2rem; }
    .nav-links a { color: white; text-decoration: none; transition: color .3s; }
    .nav-links a:hover, .nav-links a.active { color: #667eea; }
    .mobile-menu-btn {
      display: none; background: none; border: 0; color: white; font-size: 1.5rem; cursor: pointer;
    }
    @media (max-width: 800px) {
      .mobile-menu-btn { display: block; }
      .nav-links {
        position: absolute; top: 64px; right: 16px;
        background: rgba(0,0,0,0.9);
        padding: 1rem; border-radius: 10px; display: none; flex-direction: column; gap: 1rem;
      }
      .nav-links.open { display: flex; }
    }

    /* Main App */
    .drawing-section { min-height: 100vh; padding: 120px 20px 50px; }
    .drawing-header { text-align: center; margin-bottom: 2rem; }
    .drawing-header h1 { font-size: 2.5rem; margin-bottom: 0.5rem; }

    .drawing-app {
      display: grid; grid-template-columns: 320px 1fr; gap: 2rem;
      max-width: 1400px; margin: 0 auto;
      background: var(--glass);
      border-radius: 20px; padding: 2rem; backdrop-filter: blur(10px);
    }

    /* Left Panel */
    .left-panel { display: flex; flex-direction: column; gap: 1.5rem; max-height: 80vh; overflow-y: auto; }
    .panel-section { background: var(--glass); border-radius: 15px; padding: 1.5rem; }
    .panel-section h3 { margin-bottom: 1rem; color: white; font-size: 1.1rem; }

    /* Color Wheel */
    .color-wheel-container { display: flex; flex-direction: column; align-items: center; gap: 1rem; }
    .color-wheel {
      width: 180px; height: 180px; border-radius: 50%; position: relative; cursor: crosshair;
      background: conic-gradient(
        hsl(0, 100%, 50%),
        hsl(30, 100%, 50%),
        hsl(60, 100%, 50%),
        hsl(90, 100%, 50%),
        hsl(120, 100%, 50%),
        hsl(150, 100%, 50%),
        hsl(180, 100%, 50%),
        hsl(210, 100%, 50%),
        hsl(240, 100%, 50%),
        hsl(270, 100%, 50%),
        hsl(300, 100%, 50%),
        hsl(330, 100%, 50%),
        hsl(360, 100%, 50%)
      );
    }
    .color-picker {
      position: absolute; width: 12px; height: 12px; border: 2px solid white; border-radius: 50%;
      transform: translate(-50%, -50%); pointer-events: none; box-shadow: 0 0 5px rgba(0,0,0,0.5);
    }
    .color-preview { display: flex; gap: 1rem; align-items: center; width: 100%; }
    .current-color { width: 50px; height: 30px; border: 2px solid white; border-radius: 6px; cursor: pointer; background: #000000; }
    .hex-input {
      flex: 1; padding: 6px 10px; border: none; border-radius: 6px; background: rgba(255,255,255,0.9);
      font-family: monospace; font-size: .9rem;
    }

    /* Color Swatches */
    .color-swatches { display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; margin-top: 1rem; }
    .color-swatch {
      width: 20px; height: 20px; border-radius: 3px; cursor: pointer; border: 1px solid rgba(255,255,255,0.4);
      transition: transform .2s, border-color .2s;
    }
    .color-swatch:hover { transform: scale(1.1); border-color: white; }

    /* Controls */
    .control-group { margin-bottom: 1rem; }
    .control-group label { display: block; color: white; font-size: .9rem; font-weight: bold; margin-bottom: .5rem; }
    .control-group input, .control-group select {
      width: 100%; padding: 8px; border: none; border-radius: 6px; font-size: 14px; background: rgba(255,255,255,0.9);
    }
    .range-display { color: white; font-weight: bold; text-align: center; margin-top: 5px; font-size: .9rem; }

    /* Brush Preview */
    .brush-preview { width: 100%; height: 50px; background: rgba(255,255,255,0.9); border-radius: 8px; margin-top: 1rem; overflow: hidden; }
    .brush-preview canvas { width: 100%; height: 100%; }

    /* Layers */
    .layers-controls { display: flex; gap: .5rem; margin-bottom: 1rem; flex-wrap: wrap; }
    .layer-item {
      display: grid; grid-template-columns: 25px 1fr 60px; align-items: center; gap: 6px;
      background: rgba(255,255,255,0.08); padding: 6px 8px; border-radius: 6px; margin-bottom: 4px; cursor: pointer; transition: all .2s;
    }
    .layer-item:hover { background: rgba(255,255,255,0.15); }
    .layer-item.active { outline: 2px solid rgba(255,255,255,0.5); background: rgba(255,255,255,0.2); }
    .layer-visibility { width: 16px; height: 16px; }
    .layer-name { background: transparent; border: none; color: white; font-size: 11px; width: 100%; outline: none; }
    .layer-opacity { width: 50px; height: 16px; }

    /* Canvas Area */
    .canvas-area { display: flex; flex-direction: column; gap: 1rem; }
    .canvas-container { position: relative; text-align: center; flex: 1; }
    #drawingCanvas {
      border: 4px solid rgba(255,255,255,0.4); border-radius: 15px; background: white; cursor: crosshair;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3); max-width: 100%; height: auto;
    }

    /* Buttons */
    .btn {
      padding: 8px 16px;
      background: linear-gradient(45deg, #667eea, #764ba2);
      border: none; border-radius: 20px; color: white; font-size: .8rem; cursor: pointer; transition: all .3s; font-weight: bold;
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3); }
    .btn.secondary { background: rgba(255,255,255,0.2); border: 1px solid var(--glass-border); }
    .btn.secondary:hover { background: var(--glass-strong); }
    .btn.small { padding: 4px 8px; font-size: .75rem; }
    .canvas-actions { display: flex; gap: .5rem; justify-content: center; flex-wrap: wrap; }

    /* Upload Area */
    .upload-area {
      border: 2px dashed rgba(255,255,255,0.3); border-radius: 8px; padding: 1.5rem; text-align: center; transition: all .3s; cursor: pointer; font-size: .9rem;
    }
    .upload-area:hover, .upload-area.dragover { border-color: rgba(255,255,255,0.6); background: rgba(255,255,255,0.1); }
    .upload-area input[type="file"] { display: none; }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: rgba(255,255,255,0.1); border-radius: 4px; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.5); }

    /* Responsive */
    @media (max-width: 1000px) {
      .drawing-app { grid-template-columns: 1fr; gap: 1rem; }
      .left-panel { flex-direction: row; overflow-x: auto; gap: 1rem; max-height: none; }
      .panel-section { min-width: 280px; flex-shrink: 0; }
    }
    @media (max-width: 768px) {
      .left-panel { flex-direction: column; overflow-x: visible; }
      .panel-section { min-width: auto; }
      .drawing-header h1 { font-size: 2rem; }
      .canvas-actions { flex-direction: column; align-items: center; }
      .btn { width: 100%; max-width: 220px; }
    }
  </style>
</head>
<body>
  <!-- Navigation -->
  <nav>
    <div class="nav-container">
      <div class="logo">4K</div>
      <ul class="nav-links" id="navLinks">
        <li><a href="index.html">Home</a></li>
        <li><a href="pages/gallery.html">Gallery</a></li>
        <li><a href="pages/about.html">About Me</a></li>
        <li><a href="pages/commissions.html">Commissions</a></li>
        <li><a href="pages/drawing.html" class="active" aria-current="page">Draw</a></li>
      </ul>
      <button class="mobile-menu-btn" id="menuBtn" type="button" aria-label="Toggle menu">‚ò∞</button>
    </div>
  </nav>

  <!-- Drawing Section -->
  <section class="drawing-section">
    <div class="drawing-header">
      <h1>üé® Advanced Digital Art Studio</h1>
      <p>Create stunning artwork with professional tools including layers, custom brushes, and a full color wheel!</p>
    </div>

    <div class="drawing-app">
      <!-- Left Panel - Tools and Controls -->
      <div class="left-panel">
        <!-- Color Section -->
        <div class="panel-section">
          <h3>üé® Colors</h3>
          <div class="color-wheel-container">
            <div class="color-wheel" id="colorWheel" aria-label="Color wheel" role="application" tabindex="0">
              <div class="color-picker" id="colorPicker"></div>
            </div>
            <div class="color-preview">
              <div class="current-color" id="currentColor" aria-label="Current color" title="Current color"></div>
              <input type="text" class="hex-input" id="hexInput" value="#000000" placeholder="#RRGGBB" aria-label="Hex color"/>
            </div>
          </div>
          <div class="color-swatches" id="colorSwatches" aria-label="Color swatches"></div>
        </div>

        <!-- Brush Controls -->
        <div class="panel-section">
          <h3>üñåÔ∏è Brush Settings</h3>

          <div class="control-group">
            <label for="brushType">Brush Type</label>
            <select id="brushType" aria-label="Brush type">
              <option value="round">Round Brush</option>
              <option value="square">Square Brush</option>
              <option value="spray">Spray Paint</option>
              <option value="marker">Marker</option>
              <option value="pencil">Pencil</option>
              <option value="eraser">Eraser</option>
            </select>
          </div>

          <div class="control-group">
            <label for="brushSize">Brush Size</label>
            <input type="range" id="brushSize" min="1" max="100" value="5" aria-describedby="sizeDisplay"/>
            <div class="range-display" id="sizeDisplay">5px</div>
          </div>

          <div class="control-group">
            <label for="brushOpacity">Opacity</label>
            <input type="range" id="brushOpacity" min="1" max="100" value="100" aria-describedby="opacityDisplay"/>
            <div class="range-display" id="opacityDisplay">100%</div>
          </div>

          <div class="brush-preview">
            <canvas id="brushPreview" width="280" height="50"></canvas>
          </div>
        </div>

        <!-- Layers Panel -->
        <div class="panel-section">
          <h3>üìë Layers</h3>

          <div class="layers-controls">
            <button class="btn small" type="button" onclick="drawingApp.addLayer()">+ Layer</button>
            <button class="btn small secondary" type="button" onclick="drawingApp.duplicateLayer()">Duplicate</button>
            <button class="btn small secondary" type="button" onclick="drawingApp.deleteLayer()">Delete</button>
          </div>

          <div id="layersList" aria-label="Layers list"></div>
        </div>

        <!-- File Upload -->
        <div class="panel-section">
          <h3>üìÅ Import Image</h3>
          <div class="upload-area" onclick="document.getElementById('imageUpload').click()" aria-label="Upload image" role="button" tabindex="0">
            <p>üì∑ Click to upload image</p>
            <p style="font-size: .8rem; opacity: .7;">PNG, JPG, GIF supported</p>
            <input type="file" id="imageUpload" accept="image/*" multiple/>
          </div>
        </div>
      </div>

      <!-- Canvas Area -->
      <div class="canvas-area">
        <div class="canvas-container">
          <canvas id="drawingCanvas" width="900" height="700"></canvas>
        </div>

        <div class="canvas-actions">
          <button class="btn" type="button" onclick="drawingApp.clearActiveLayer()">Clear Layer</button>
          <button class="btn" type="button" onclick="drawingApp.clearAllLayers()">Clear All</button>
          <button class="btn" type="button" onclick="drawingApp.undoLastStroke()">‚Ü∂ Undo</button>
          <button class="btn" type="button" onclick="drawingApp.redoLastStroke()">‚Ü∑ Redo</button>
          <button class="btn secondary" type="button" onclick="drawingApp.saveAsImage()">üíæ Save Image</button>
          <button class="btn secondary" type="button" onclick="drawingApp.saveProject()">üìÑ Save Project</button>
          <button class="btn secondary" type="button" onclick="drawingApp.loadProject()">üìÅ Load Project</button>
        </div>
      </div>
    </div>
  </section>

  <script src="main.js" defer></script>
  <script>
    // Utility: add non-passive listener
    const addNP = (el, type, handler) => el.addEventListener(type, handler, { passive: false });

    // ===== Layer class =====
    class Layer {
      constructor(width, height, name = "Layer") {
        this.id = Date.now() + Math.random();
        this.name = name;
        this.visible = true;
        this.opacity = 1.0;
        this.canvas = document.createElement('canvas');
        this.canvas.width = width;
        this.canvas.height = height;
        this.ctx = this.canvas.getContext('2d');
        this.undoStack = [];
        this.redoStack = [];
        this.ctx.clearRect(0, 0, width, height);
        this.saveState();
      }
      saveState() {
        try {
          const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
          this.undoStack.push(imageData);
          if (this.undoStack.length > 20) this.undoStack.shift(); // slightly lower cap
          this.redoStack = [];
        } catch (e) { console.log('Could not save state'); }
      }
      undo() {
        if (this.undoStack.length <= 1) return false;
        const currentState = this.undoStack.pop();
        this.redoStack.push(currentState);
        const previousState = this.undoStack[this.undoStack.length - 1];
        this.ctx.putImageData(previousState, 0, 0);
        return true;
      }
      redo() {
        if (!this.redoStack.length) return false;
        const state = this.redoStack.pop();
        this.undoStack.push(state);
        this.ctx.putImageData(state, 0, 0);
        return true;
      }
      clear() {
        this.saveState();
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
    }

    // ===== Main App =====
    class DrawingApp {
      constructor() {
        this.canvas = document.getElementById('drawingCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.layers = [];
        this.activeLayerIndex = 0;
        this.isDrawing = false;
        this.lastX = 0; this.lastY = 0;
        this.currentColor = '#000000';
        this.currentOpacity = 1;
        this.currentSize = 5;
        this.currentTool = 'round';
        this.dpr = window.devicePixelRatio || 1;

        this.init();
      }

      init() {
        this.setupCanvasDPR();
        this.createDefaultLayers();
        this.setupEventListeners();
        this.setupColorWheel();
        this.setupColorSwatches();
        this.updateBrushPreview();
        this.updateLayersPanel();
        this.renderCanvas();
        this.setupMenuToggle();
      }

      setupMenuToggle() {
        const btn = document.getElementById('menuBtn');
        const links = document.getElementById('navLinks');
        btn.addEventListener('click', () => links.classList.toggle('open'));
      }

      setupCanvasDPR() {
        // Scale backing store for crisp strokes
        const displayW = this.canvas.getAttribute('width');
        const displayH = this.canvas.getAttribute('height');
        this.canvas.width = displayW * this.dpr;
        this.canvas.height = displayH * this.dpr;
        this.canvas.style.width = displayW + 'px';
        this.canvas.style.height = displayH + 'px';
        this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);

        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.fillStyle = 'white';
        this.ctx.fillRect(0, 0, displayW, displayH);
      }

      createDefaultLayers() {
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;

        const bg = new Layer(w, h, 'Background');
        bg.ctx.fillStyle = 'white';
        bg.ctx.fillRect(0, 0, w, h);
        bg.saveState();
        this.layers.push(bg);

        const draw = new Layer(w, h, 'Layer 1');
        this.layers.push(draw);
        this.activeLayerIndex = 1;
      }

      setupEventListeners() {
        // Pointer/mouse events
        this.canvas.addEventListener('mousedown', e => this.startDrawing(e));
        this.canvas.addEventListener('mousemove', e => this.draw(e));
        document.addEventListener('mouseup', () => this.stopDrawing());

        // Touch events (non-passive)
        addNP(this.canvas, 'touchstart', e => {
          e.preventDefault();
          const t = e.touches[0];
          this.startDrawing({ clientX: t.clientX, clientY: t.clientY });
        });
        addNP(this.canvas, 'touchmove', e => {
          e.preventDefault();
          const t = e.touches[0];
          this.draw({ clientX: t.clientX, clientY: t.clientY });
        });
        addNP(this.canvas, 'touchend', e => {
          e.preventDefault();
          this.stopDrawing();
        });

        // Controls
        document.getElementById('brushSize').addEventListener('input', e => {
          this.currentSize = parseInt(e.target.value, 10);
          document.getElementById('sizeDisplay').textContent = e.target.value + 'px';
          this.updateBrushPreview();
        });
        document.getElementById('brushOpacity').addEventListener('input', e => {
          this.currentOpacity = e.target.value / 100;
          document.getElementById('opacityDisplay').textContent = e.target.value + '%';
          this.updateBrushPreview();
        });
        document.getElementById('brushType').addEventListener('change', e => {
          this.currentTool = e.target.value;
          this.updateBrushPreview();
        });

        // Hex input with normalization
        document.getElementById('hexInput').addEventListener('input', e => {
          const norm = this.normalizeHex(e.target.value);
          if (norm) this.setColor(norm);
        });

        // Image upload & DnD
        document.getElementById('imageUpload').addEventListener('change', e => this.handleImageUpload(e));
        this.setupDragAndDrop();

        // Keyboard shortcuts
        document.addEventListener('keydown', e => {
          if (e.ctrlKey || e.metaKey) {
            switch (e.key.toLowerCase()) {
              case 'z': e.preventDefault(); e.shiftKey ? this.redoLastStroke() : this.undoLastStroke(); break;
              case 'y': e.preventDefault(); this.redoLastStroke(); break;
              case 's': e.preventDefault(); this.saveProject(); break;
            }
          }
        });
      }

      setupDragAndDrop() {
        const uploadArea = document.querySelector('.upload-area');
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev =>
          uploadArea.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); })
        );
        ['dragenter', 'dragover'].forEach(ev =>
          uploadArea.addEventListener(ev, () => uploadArea.classList.add('dragover'))
        );
        ['dragleave', 'drop'].forEach(ev =>
          uploadArea.addEventListener(ev, () => uploadArea.classList.remove('dragover'))
        );
        uploadArea.addEventListener('drop', e => this.handleFiles(e.dataTransfer.files));
      }

      // Color wheel with drag (pointer events)
      setupColorWheel() {
        this.colorWheel = document.getElementById('colorWheel');
        this.colorPicker = document.getElementById('colorPicker');

        const pickAt = (clientX, clientY) => {
          const rect = this.colorWheel.getBoundingClientRect();
          const x = clientX - rect.left;
          const y = clientY - rect.top;
          const cx = rect.width / 2;
          const cy = rect.height / 2;
          const angle = Math.atan2(y - cy, x - cx);
          const dist = Math.hypot(x - cx, y - cy);
          const radius = Math.min(cx, cy);

          if (dist <= radius) {
            const hue = ((angle * 180 / Math.PI) + 360) % 360;
            const sat = Math.min((dist / radius) * 100, 100);
            const light = 50;
            const color = this.hslToHex(hue, sat, light);
            this.setColor(color);
            this.colorPicker.style.left = x + 'px';
            this.colorPicker.style.top  = y + 'px';
          }
        };

        let dragging = false;
        const onPointerDown = e => { dragging = true; pickAt(e.clientX, e.clientY); };
        const onPointerMove = e => { if (dragging) pickAt(e.clientX, e.clientY); };
        const onPointerUp = () => { dragging = false; };

        this.colorWheel.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);

        // Initial picker position (center)
        this.colorPicker.style.left = '90px';
        this.colorPicker.style.top  = '90px';
      }

      setupColorSwatches() {
        const swatchesContainer = document.getElementById('colorSwatches');
        const commonColors = [
          '#000000','#FFFFFF','#FF0000','#00FF00','#0000FF','#FFFF00',
          '#FF00FF','#00FFFF','#800000','#008000','#000080','#808000',
          '#800080','#008080','#C0C0C0','#808080','#FFC0CB','#FFB6C1',
          '#FF69B4','#FF1493','#DC143C','#B22222','#8B0000','#FF6347',
          '#FF7F50','#FF4500','#FF8C00','#FFA500','#FFD700','#9ACD32'
        ];
        swatchesContainer.innerHTML = '';
        commonColors.forEach(color => {
          const sw = document.createElement('div');
          sw.className = 'color-swatch';
          sw.style.backgroundColor = color;
          sw.title = color;
          sw.addEventListener('click', () => this.setColor(color));
          swatchesContainer.appendChild(sw);
        });
      }

      setColor(color) {
        const norm = this.normalizeHex(color);
        if (!norm) return;
        this.currentColor = norm;
        document.getElementById('currentColor').style.backgroundColor = norm;
        document.getElementById('hexInput').value = norm;
        this.updateBrushPreview();
      }

      normalizeHex(input) {
        if (!input) return null;
        let s = input.trim().toLowerCase();
        if (s.startsWith('#')) s = s.slice(1);
        if (s.length === 3 && /^[0-9a-f]{3}$/i.test(s)) {
          s = s.split('').map(ch => ch + ch).join('');
        }
        if (/^[0-9a-f]{6}$/i.test(s)) return '#' + s.toUpperCase();
        return null;
      }

      isBackgroundActive() {
        return this.layers[this.activeLayerIndex]?.name === 'Background';
      }

      getMousePosition(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = (this.canvas.width / this.dpr) / rect.width;
        const scaleY = (this.canvas.height / this.dpr) / rect.height;
        return {
          x: (e.clientX - rect.left) * scaleX,
          y: (e.clientY - rect.top)  * scaleY
        };
      }

      startDrawing(e) {
        if (!this.layers.length) return;
        // Prevent drawing on background
        if (this.isBackgroundActive() && this.currentTool !== 'square') return;

        this.isDrawing = true;
        const pos = this.getMousePosition(e);
        this.lastX = pos.x; this.lastY = pos.y;
        this.getActiveLayer().saveState();
      }

      draw(e) {
        if (!this.isDrawing || !this.layers.length) return;
        if (this.isBackgroundActive() && this.currentTool !== 'square') return;

        const pos = this.getMousePosition(e);
        const layer = this.getActiveLayer();
        const ctx = layer.ctx;

        ctx.save();
        ctx.globalAlpha = this.currentOpacity;

        switch (this.currentTool) {
          case 'round':  this.drawRoundBrush(ctx, pos); break;
          case 'square': this.drawSquareBrush(ctx, pos); break;
          case 'spray':  this.drawSprayBrush(ctx, pos); break;
          case 'marker': this.drawMarker(ctx, pos); break;
          case 'pencil': this.drawPencil(ctx, pos); break;
          case 'eraser': this.drawEraser(ctx, pos); break;
        }
        ctx.restore();

        this.lastX = pos.x; this.lastY = pos.y;
        this.renderCanvas();
      }

      stopDrawing() { this.isDrawing = false; }

      drawRoundBrush(ctx, pos) {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = this.currentColor;
        ctx.lineWidth = this.currentSize;
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath(); ctx.moveTo(this.lastX, this.lastY); ctx.lineTo(pos.x, pos.y); ctx.stroke();
      }
      drawSquareBrush(ctx, pos) {
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = this.currentColor;
        ctx.fillRect(pos.x - this.currentSize/2, pos.y - this.currentSize/2, this.currentSize, this.currentSize);
      }
      drawSprayBrush(ctx, pos) {
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = this.currentColor;
        const density = 20;
        for (let i = 0; i < density; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = Math.random() * this.currentSize;
          const x = pos.x + Math.cos(angle) * dist;
          const y = pos.y + Math.sin(angle) * dist;
          ctx.beginPath(); ctx.arc(x, y, Math.random() * 2 + 0.5, 0, Math.PI * 2); ctx.fill();
        }
      }
      drawMarker(ctx, pos) {
        ctx.globalCompositeOperation = 'multiply';
        ctx.strokeStyle = this.currentColor;
        ctx.lineWidth = this.currentSize; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.globalAlpha *= 0.7;
        ctx.beginPath(); ctx.moveTo(this.lastX, this.lastY); ctx.lineTo(pos.x, pos.y); ctx.stroke();
      }
      drawPencil(ctx, pos) {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = this.currentColor;
        ctx.lineWidth = Math.max(1, this.currentSize * 0.5);
        ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.globalAlpha *= 0.8;
        const jitter = 0.5;
        const jx = (Math.random() - 0.5) * jitter;
        const jy = (Math.random() - 0.5) * jitter;
        ctx.beginPath(); ctx.moveTo(this.lastX + jx, this.lastY + jy); ctx.lineTo(pos.x + jx, pos.y + jy); ctx.stroke();
      }
      drawEraser(ctx, pos) {
        if (this.isBackgroundActive()) return; // hard stop on background
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineWidth = this.currentSize; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath(); ctx.moveTo(this.lastX, this.lastY); ctx.lineTo(pos.x, pos.y); ctx.stroke();
      }

      updateBrushPreview() {
        const canvas = document.getElementById('brushPreview');
        const dpr = window.devicePixelRatio || 1;
        const displayW = canvas.getAttribute('width');
        const displayH = canvas.getAttribute('height');
        canvas.width = displayW * dpr; canvas.height = displayH * dpr;
        canvas.style.width = displayW + 'px'; canvas.style.height = displayH + 'px';
        const ctx = canvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        ctx.clearRect(0, 0, displayW, displayH);
        ctx.save();
        ctx.globalAlpha = this.currentOpacity;
        ctx.strokeStyle = this.currentColor;
        ctx.fillStyle = this.currentColor;
        ctx.lineWidth = this.currentSize;
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';

        const cy = displayH / 2; const startX = 20; const endX = displayW - 20;
        switch (this.currentTool) {
          case 'round':
          case 'marker':
          case 'pencil':
            ctx.beginPath(); ctx.moveTo(startX, cy); ctx.lineTo(endX, cy); ctx.stroke(); break;
          case 'square':
            for (let x = startX; x < endX; x += this.currentSize + 2) {
              ctx.fillRect(x - this.currentSize/2, cy - this.currentSize/2, this.currentSize, this.currentSize);
            } break;
          case 'spray':
            for (let x = startX; x < endX; x += 8) {
              for (let i = 0; i < 10; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * this.currentSize;
                const px = x + Math.cos(angle) * dist;
                const py = cy + Math.sin(angle) * dist;
                ctx.beginPath(); ctx.arc(px, py, 1, 0, Math.PI * 2); ctx.fill();
              }
            } break;
          case 'eraser':
            ctx.fillStyle = '#f0f0f0'; ctx.fillRect(0, 0, displayW, displayH);
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath(); ctx.moveTo(startX, cy); ctx.lineTo(endX, cy); ctx.stroke(); break;
        }
        ctx.restore();
      }

      getActiveLayer() { return this.layers[this.activeLayerIndex]; }

      addLayer(name = null) {
        const layerName = name || `Layer ${this.layers.length}`;
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const newLayer = new Layer(w, h, layerName);
        this.layers.push(newLayer);
        this.activeLayerIndex = this.layers.length - 1;
        this.updateLayersPanel();
        this.renderCanvas();
      }

      duplicateLayer() {
        if (!this.layers.length) return;
        const active = this.getActiveLayer();
        const w = this.canvas.width / this.dpr, h = this.canvas.height / this.dpr;
        const copy = new Layer(w, h, active.name + ' Copy');
        copy.ctx.drawImage(active.canvas, 0, 0);
        copy.saveState();
        this.layers.splice(this.activeLayerIndex + 1, 0, copy);
        this.activeLayerIndex++;
        this.updateLayersPanel(); this.renderCanvas();
      }

      deleteLayer() {
        if (this.layers.length <= 1) return;
        // prevent deleting background if only two layers? (optional)
        this.layers.splice(this.activeLayerIndex, 1);
        this.activeLayerIndex = Math.min(this.activeLayerIndex, this.layers.length - 1);
        this.updateLayersPanel(); this.renderCanvas();
      }

      setActiveLayer(index) {
        if (index >= 0 && index < this.layers.length) {
          this.activeLayerIndex = index;
          this.updateLayersPanel();
        }
      }

      toggleLayerVisibility(index) {
        if (index >= 0 && index < this.layers.length) {
          this.layers[index].visible = !this.layers[index].visible;
          this.updateLayersPanel(); this.renderCanvas();
        }
      }

      setLayerOpacity(index, opacity) {
        if (index >= 0 && index < this.layers.length) {
          this.layers[index].opacity = opacity;
          this.renderCanvas();
        }
      }

      updateLayersPanel() {
        const layersList = document.getElementById('layersList');
        layersList.innerHTML = '';

        for (let i = this.layers.length - 1; i >= 0; i--) {
          const layer = this.layers[i];
          const row = document.createElement('div');
          row.className = 'layer-item' + (i === this.activeLayerIndex ? ' active' : '');

          row.innerHTML = `
            <input type="checkbox" class="layer-visibility" ${layer.visible ? 'checked' : ''} aria-label="Toggle visibility">
            <input type="text" class="layer-name" value="${layer.name}">
            <input type="range" class="layer-opacity" min="0" max="100" value="${Math.round(layer.opacity * 100)}" aria-label="Layer opacity">
          `;

          const vis = row.querySelector('.layer-visibility');
          const name = row.querySelector('.layer-name');
          const op   = row.querySelector('.layer-opacity');

          // stop inputs from stealing the row's click
          [vis, name, op].forEach(el => el.addEventListener('click', e => e.stopPropagation()));

          vis.addEventListener('change', () => this.toggleLayerVisibility(i));
          name.addEventListener('change', () => { layer.name = name.value; });
          op.addEventListener('input', () => this.setLayerOpacity(i, op.value / 100));

          row.addEventListener('click', () => this.setActiveLayer(i));
          layersList.appendChild(row);
        }
      }

      renderCanvas() {
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;

        this.ctx.save();
        this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
        this.ctx.fillStyle = 'white';
        this.ctx.fillRect(0, 0, w, h);

        for (const layer of this.layers) {
          if (layer.visible) {
            this.ctx.globalAlpha = layer.opacity;
            this.ctx.drawImage(layer.canvas, 0, 0);
          }
        }
        this.ctx.restore();
      }

      clearActiveLayer() {
        if (!this.layers.length) return;
        if (this.isBackgroundActive()) return; // don't clear background via button
        this.getActiveLayer().clear(); this.renderCanvas();
      }

      clearAllLayers() {
        this.layers.forEach(layer => { if (layer.name !== 'Background') layer.clear(); });
        this.renderCanvas();
      }

      undoLastStroke() {
        if (!this.layers.length) return;
        const layer = this.getActiveLayer();
        if (layer.undo()) this.renderCanvas();
      }
      redoLastStroke() {
        if (!this.layers.length) return;
        const layer = this.getActiveLayer();
        if (layer.redo()) this.renderCanvas();
      }

      handleImageUpload(e) { this.handleFiles(e.target.files); }
      handleFiles(files) {
        Array.from(files).forEach(file => {
          if (file.type.startsWith('image/')) this.loadImageToLayer(file);
        });
      }

      loadImageToLayer(file) {
        const reader = new FileReader();
        reader.onload = e => {
          const img = new Image();
          img.onload = () => {
            const layerName = `Image: ${file.name.substring(0, 15)}`;
            this.addLayer(layerName);
            const layer = this.getActiveLayer();
            const ctx = layer.ctx;
            const cw = this.canvas.width / this.dpr;
            const ch = this.canvas.height / this.dpr;
            const scale = Math.min(cw / img.width, ch / img.height);
            const sw = img.width * scale, sh = img.height * scale;
            const x = (cw - sw) / 2, y = (ch - sh) / 2;
            ctx.drawImage(img, x, y, sw, sh);
            layer.saveState();
            this.renderCanvas();
            this.updateLayersPanel();
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      }

      saveAsImage() {
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const temp = document.createElement('canvas');
        temp.width = w; temp.height = h;
        const tctx = temp.getContext('2d');

        tctx.fillStyle = 'white'; tctx.fillRect(0, 0, w, h);
        for (const layer of this.layers) {
          if (layer.visible) {
            tctx.globalAlpha = layer.opacity;
            tctx.drawImage(layer.canvas, 0, 0);
          }
        }
        const link = document.createElement('a');
        link.download = `artwork-${Date.now()}.png`;
        link.href = temp.toDataURL('image/png');
        link.click();
      }

      saveProject() {
        const projectData = {
          version: '1.1',
          width: this.canvas.width / this.dpr,
          height: this.canvas.height / this.dpr,
          activeLayerIndex: this.activeLayerIndex,
          layers: this.layers.map(l => ({
            id: l.id, name: l.name, visible: l.visible, opacity: l.opacity,
            imageData: l.canvas.toDataURL('image/png')
          }))
        };
        const blob = new Blob([JSON.stringify(projectData)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `project-${Date.now()}.json`;
        link.click();
        URL.revokeObjectURL(url);
      }

      loadProject() {
        const input = document.createElement('input');
        input.type = 'file'; input.accept = '.json';
        input.onchange = e => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = e => {
            try { this.loadProjectData(JSON.parse(e.target.result)); }
            catch { alert('Error loading project: Invalid file format'); }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      async loadProjectData(data) {
        this.layers = [];
        const w = data.width || (this.canvas.width / this.dpr);
        const h = data.height || (this.canvas.height / this.dpr);

        for (const ld of data.layers) {
          const layer = new Layer(w, h, ld.name);
          layer.id = ld.id; layer.visible = ld.visible; layer.opacity = ld.opacity;
          if (ld.imageData) {
            const img = new Image();
            await new Promise(res => {
              img.onload = () => { layer.ctx.drawImage(img, 0, 0); layer.saveState(); res(); };
              img.onerror = () => res();
              img.src = ld.imageData;
            });
          }
          this.layers.push(layer);
        }
        this.activeLayerIndex = Math.min(data.activeLayerIndex || 0, this.layers.length - 1);
        this.updateLayersPanel(); this.renderCanvas();
        alert('Project loaded successfully!');
      }
    }

    // Initialize the app
    let drawingApp;
    document.addEventListener('DOMContentLoaded', () => {
      drawingApp = new DrawingApp();
      document.getElementById('currentColor').style.backgroundColor = '#000000';
    });
  </script>
</body>
</html>
